/*
 * This file is part of ZTE-Cli-Tool.
 *
 * ZTE-Cli-Tool is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * ZTE-Cli-Tool is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * Author: Thomas PÃ¶chtrager (email: t.poechtrager@gmail.com)
 * Remarks: A lot of the code in here has been generated by OpenAI ChatGPT.
 * Year: 2023
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <gnutls/gnutls.h>
#include <pthread.h>
#include <assert.h>
#include <getopt.h>

const char *routerIp;
int listenPort;

#define CHECK(x) assert((x)>=0)

#define MAX_HEADERS 50

// Structure to store key-value pairs for HTTP headers
struct KeyValue {
    char key[2048];
    char value[8192];
};

// Function to parse an HTTP request and store header fields in key-value pairs
int parseHttpRequest(const char *request, struct KeyValue *headers) {
    int numHeaders = 0;
    const char *lineStart = request;
    const char *lineEnd = strstr(lineStart, "\r\n");

    while (lineEnd != NULL) {
        if (numHeaders >= MAX_HEADERS) {
            // Too many headers, can't parse further
            return -1;
        }

        // Find the colon separator in the header line
        const char *colon = strchr(lineStart, ':');
        if (colon == NULL || colon >= lineEnd) {
            // Malformed header line, skip it
            lineStart = lineEnd + 2; // Move to the next line
            lineEnd = strstr(lineStart, "\r\n");
            continue;
        }

        // Calculate the key length and ensure it fits in the buffer
        size_t keyLength = colon - lineStart;
        if (keyLength >= sizeof(headers[numHeaders].key) - 1) {
            return -1;
        }

        // Copy the key to the headers array
        memcpy(headers[numHeaders].key, lineStart, keyLength);
        headers[numHeaders].key[keyLength] = '\0';

        const char *valueStart = colon + 1;

        // Skip white space
        while (*valueStart == ' ' || *valueStart == '\t') {
            valueStart++;
        }

        // Calculate the value length and ensure it fits in the buffer
        size_t valueLength = lineEnd - valueStart;
        if (valueLength >= sizeof(headers[numHeaders].value) - 1) {
            return -1;
        }

        // Copy the value to the headers array
        memcpy(headers[numHeaders].value, valueStart, valueLength);
        headers[numHeaders].value[valueLength] = '\0';

        // Move to the next line
        lineStart = lineEnd + 2;
        lineEnd = strstr(lineStart, "\r\n");

        numHeaders++;
    }

    return numHeaders;
}

// Function to update an HTTP request's headers based on a key-value pair
void updateHttpRequest(struct KeyValue *headers, int *numHeaders, const char *key, const char *value) {
    for (int i = 0; i < *numHeaders; i++) {
        if (strcmp(headers[i].key, key) == 0) {
            // Safely copy the value
            size_t valueLength = strlen(value);
            if (valueLength >= sizeof(headers[i].value) - 1) {
                valueLength = sizeof(headers[i].value) - 1;
            }
            memcpy(headers[i].value, value, valueLength);
            headers[i].value[valueLength] = '\0';

            return; // Exit early if the key is found and updated
        }
    }
    // If the key is not found, add it as a new header
    if (*numHeaders < MAX_HEADERS) {
        // Safely copy the key
        size_t keyLength = strlen(key);
        if (keyLength >= sizeof(headers[*numHeaders].key) - 1) {
            keyLength = sizeof(headers[*numHeaders].key) - 1;
        }
        memcpy(headers[*numHeaders].key, key, keyLength);
        headers[*numHeaders].key[keyLength] = '\0';

        // Safely copy the value
        size_t valueLength = strlen(value);
        if (valueLength >= sizeof(headers[*numHeaders].value) - 1) {
            valueLength = sizeof(headers[*numHeaders].value) - 1;
        }
        memcpy(headers[*numHeaders].value, value, valueLength);
        headers[*numHeaders].value[valueLength] = '\0';

        (*numHeaders)++;
    }
}

// Retrieves the value of a specified HTTP header from an array of key-value pairs.
const char *getHttpRequestHeader(struct KeyValue *headers, int numHeaders, const char *key) {
    for (int i = 0; i < numHeaders; i++) {
        if (strcmp(headers[i].key, key) == 0) {
            return headers[i].value;
        }
    }
    return NULL;
}

const char *parseRequestFromURL(const char *url) {
    // Find the position of "//" in the URL
    const char *protocolSeparator = strstr(url, "//");
    
    // If "//" was found, move the pointer to the character after it
    if (protocolSeparator != NULL) {
        protocolSeparator += 2;
    } else {
        return NULL; // If no "//" found, return NULL
    }
    
    // Find the position of the first '/' after "//"
    const char *pathSeparator = strchr(protocolSeparator, '/');
    
    // If a '/' was found, return the pointer to it (the request)
    if (pathSeparator != NULL) {
        return pathSeparator + 1;
    }
    
    return NULL; // If no '/' was found after "//", return NULL
}


// Function to initialize the GnuTLS session for the client
int initializeClientSession(gnutls_session_t *clientSession) {
    // Initialize a GnuTLS session as a client
    CHECK(gnutls_init(clientSession, GNUTLS_CLIENT));
    
    // Set the default priority for ciphers, key exchange methods, etc.
    CHECK(gnutls_set_default_priority(*clientSession));

    // Create X.509 credentials object
    gnutls_certificate_credentials_t x509Credentials;
    CHECK(gnutls_certificate_allocate_credentials(&x509Credentials));

    // Load the system's trusted CAs
    CHECK(gnutls_certificate_set_x509_system_trust(x509Credentials));

    // Set the client's own cert and private key from PEM files
    gnutls_certificate_set_x509_key_file(
        x509Credentials, 
        "cert.pem", 
        "key.pem", 
        GNUTLS_X509_FMT_PEM
    );

    // Set the credentials to the session
    CHECK(gnutls_credentials_set(*clientSession, GNUTLS_CRD_CERTIFICATE, x509Credentials));

    // Add a trusted CA file
    gnutls_certificate_set_x509_trust_file(
        x509Credentials, 
        "ca_cert.pem", 
        GNUTLS_X509_FMT_PEM
    );

    return 0;
}


// Function to establish a connection to the destination server
int connectToDestination(int *destinationSocketFd) {
    // Initialize destination address structure
    struct sockaddr_in destinationAddress;
    memset(&destinationAddress, 0, sizeof(destinationAddress));
    destinationAddress.sin_family = AF_INET;
    destinationAddress.sin_port = htons(443);

    // Convert destination IP from text to binary
    if (inet_pton(AF_INET, routerIp, &(destinationAddress.sin_addr)) <= 0) {
        perror("inet_pton");
        return -1;
    }

    // Create the socket
    *destinationSocketFd = socket(AF_INET, SOCK_STREAM, 0);
    if (*destinationSocketFd < 0) {
        perror("socket");
        return -1;
    }

    // Establish the connection
    if (connect(*destinationSocketFd, (struct sockaddr *)&destinationAddress, sizeof(destinationAddress)) < 0) {
        perror("connect");
        return -1;
    }

    return 0;
}

// Function to perform the TLS handshake
int performTlsHandshake(gnutls_session_t tlsSession) {
    int tlsHandshakeResult;

    // Continue the handshake until it's complete or a fatal error occurs
    do {
        tlsHandshakeResult = gnutls_handshake(tlsSession);
    } while (tlsHandshakeResult < 0 && 
             gnutls_error_is_fatal(tlsHandshakeResult) == 0);

    // Check for handshake errors
    if (tlsHandshakeResult < 0) {
        gnutls_perror(tlsHandshakeResult);
        return -1;
    }

    return 0;
}

// Function to adjust HTTP request before forwarding it.
// Fix Host:
// Fix Referer:
int adjustHttpRequest(
    const char *incomingData,
    size_t incomingDataLength,
    char *updatedRequest,
    size_t updatedRequestBufferSize,
    size_t *updatedRequestLength)
{
    // Initialize the length of the updated request to zero
    *updatedRequestLength = 0;

    // Buffer to hold the initial HTTP GET or POST line
    char httpGetOrPostLine[2048];

    const char *initialRequestStart = incomingData;
    const char *initialRequestEnd = strstr(initialRequestStart, "\r\n");

    // If we can't find the end of the initial line, return 0
    if (initialRequestEnd == NULL) {
        return 0;
    }

    size_t initialRequestLength = initialRequestEnd - initialRequestStart;

    // Validate length to prevent buffer overflow
    if (initialRequestLength >= sizeof(httpGetOrPostLine) - 1) {
        return 0;
    }

    // Copy the initial line to the buffer
    memcpy(httpGetOrPostLine, initialRequestStart, initialRequestLength);
    httpGetOrPostLine[initialRequestLength] = '\0';
    initialRequestEnd += 2; // Skip "\r\n"

    // Buffer for HTTP headers
    char headerBuffer[2048];
    const char *headerSectionEnd = strstr(initialRequestEnd, "\r\n\r\n");
    size_t headerSectionLength = headerSectionEnd - initialRequestEnd + 4;

    // Validate header section length
    if (headerSectionLength >= sizeof(headerBuffer) - 1) {
        return 0;
    }

    // Copy headers to the buffer
    memcpy(headerBuffer, initialRequestEnd, headerSectionLength);
    headerBuffer[headerSectionLength] = '\0';

    // Parse headers
    struct KeyValue parsedHeaders[MAX_HEADERS];
    int numParsedHeaders = parseHttpRequest(headerBuffer, parsedHeaders);

    // Buffer for request body
    char requestBody[8192];
    headerSectionEnd += 4; // Skip "\r\n\r\n"
    size_t requestBodyLength = 
        &incomingData[incomingDataLength] - headerSectionEnd;

    // Validate request body length
    if (requestBodyLength >= sizeof(requestBody) - 1) {
        return 0;
    }

    // Copy request body to buffer
    memcpy(requestBody, headerSectionEnd, requestBodyLength);
    requestBody[requestBodyLength] = '\0';

    // Update headers
    updateHttpRequest(parsedHeaders, &numParsedHeaders, "Host", routerIp);

    // Get original "Referer" if available
    const char *originalReferer = 
        getHttpRequestHeader(parsedHeaders, numParsedHeaders, "Referer");
    const char *originalRefererRequest = "";

    // Parse original referer if available
    if (originalReferer) {
        originalRefererRequest = parseRequestFromURL(originalReferer);
        if (!originalRefererRequest) return 0;
    }

    // Update "Referer" header
    char newReferer[1024];
    snprintf(newReferer, sizeof(newReferer), "https://%s/%s", 
             routerIp, originalRefererRequest);
    updateHttpRequest(parsedHeaders, &numParsedHeaders, "Referer", newReferer);

    // Build the updated request
    *updatedRequestLength += snprintf(
        updatedRequest + *updatedRequestLength,
        updatedRequestBufferSize - *updatedRequestLength,
        "%s", httpGetOrPostLine
    );

    for (int i = 0; i < numParsedHeaders; i++) {
        *updatedRequestLength += snprintf(
            updatedRequest + *updatedRequestLength,
            updatedRequestBufferSize - *updatedRequestLength,
            "\r\n%s: %s", parsedHeaders[i].key, parsedHeaders[i].value
        );
    }

    *updatedRequestLength += snprintf(
        updatedRequest + *updatedRequestLength,
        updatedRequestBufferSize - *updatedRequestLength,
        "\r\n\r\n%s", requestBody
    );

    return 1; // Indicate success
}

int forwardDataBetweenClientAndRouter(
    gnutls_session_t tlsSession, 
    int clientSocket, 
    int destinationSocket
) {
    char dataBuffer[10240];
    ssize_t bytesRead, bytesSent;

    while (1) {
        fd_set readSocketSet;
        FD_ZERO(&readSocketSet);

        // Add client and destination sockets to the read set
        FD_SET(clientSocket, &readSocketSet);
        FD_SET(destinationSocket, &readSocketSet);

        struct timeval selectTimeout;
        selectTimeout.tv_sec = 1;
        selectTimeout.tv_usec = 0;

        int maxSocketFd = (clientSocket > destinationSocket) ? clientSocket : destinationSocket;

        // Wait for socket events
        int activeSockets = select(maxSocketFd + 1, &readSocketSet, NULL, NULL, &selectTimeout);

        if (activeSockets < 0) {
            perror("select");
            break;
        } else if (activeSockets == 0) {
            continue;
        } else {
            if (FD_ISSET(clientSocket, &readSocketSet)) {
                bytesRead = recv(clientSocket, dataBuffer, sizeof(dataBuffer) - 1, 0);
                if (bytesRead <= 0) {
                    break;
                }

                dataBuffer[bytesRead] = '\0';

                char adjustedHttpRequest[10240];
                size_t adjustedHttpRequestLength = 0;

                // Adjust the request to avoid router rejection
                if (bytesRead >= 16 && 
                    (!strncmp(dataBuffer, "GET /", 5) || !strncmp(dataBuffer, "POST /", 6))
                ) {
                    if (!adjustHttpRequest(
                        dataBuffer, bytesRead, 
                        adjustedHttpRequest, sizeof(adjustedHttpRequest), 
                        &adjustedHttpRequestLength)
                    ) {
                        return 0;
                    }
                }

                const char *payloadToSend;
                size_t payloadLength;

                if (adjustedHttpRequestLength > 0) {
                    payloadToSend = adjustedHttpRequest;
                    payloadLength = adjustedHttpRequestLength;
                } else {
                    payloadToSend = dataBuffer;
                    payloadLength = bytesRead;
                }

                bytesSent = gnutls_record_send(
                    tlsSession, payloadToSend, payloadLength
                );

                if (bytesSent <= 0) {
                    gnutls_perror(bytesSent);
                    break;
                }
            }

            if (FD_ISSET(destinationSocket, &readSocketSet)) {
                bytesRead = gnutls_record_recv(
                    tlsSession, dataBuffer, sizeof(dataBuffer) - 1
                );
                if (bytesRead <= 0) {
                    break;
                }

                dataBuffer[bytesRead] = '\0';

                bytesSent = send(clientSocket, dataBuffer, bytesRead, 0);

                if (bytesSent <= 0) {
                    perror("send");
                    break;
                }
            }
        }
    }

    return 0;
}

void cleanUpResources(gnutls_session_t tlsSession, int clientSocketFd, int destinationSocketFd) {
    // Terminate the GnuTLS session gracefully
    gnutls_bye(tlsSession, GNUTLS_SHUT_WR);

    // Deinitialize the GnuTLS session
    gnutls_deinit(tlsSession);

    // Close the client and destination sockets
    close(clientSocketFd);
    close(destinationSocketFd);
}

void *handleClient(void *arg) {
    // Retrieve and cast the client socket file descriptor from the argument
    int clientSocketFd = *((int *)arg);

    // Initialize a GnuTLS session for the client
    gnutls_session_t tlsSession;
    if (initializeClientSession(&tlsSession) < 0) {
        close(clientSocketFd);
        return NULL;
    }

    // Establish a connection to the destination HTTPS server
    int destinationSocketFd;
    if (connectToDestination(&destinationSocketFd) < 0) {
        cleanUpResources(tlsSession, clientSocketFd, destinationSocketFd);
        return NULL;
    }

    // Set transport layer and timeout for the GnuTLS session
    gnutls_transport_set_int(tlsSession, destinationSocketFd);
    gnutls_handshake_set_timeout(tlsSession, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

    // Perform the TLS handshake
    if (performTlsHandshake(tlsSession) < 0) {
        cleanUpResources(tlsSession, clientSocketFd, destinationSocketFd);
        return NULL;
    }

    // Forward data between the client and the destination server
    if (forwardDataBetweenClientAndRouter(tlsSession, clientSocketFd, destinationSocketFd) < 0) {
        cleanUpResources(tlsSession, clientSocketFd, destinationSocketFd);
        return NULL;
    }

    // Clean up resources before exiting
    cleanUpResources(tlsSession, clientSocketFd, destinationSocketFd);

    return NULL;
}

void forkToBackground() {
    printf("Forking to background...\n");

    // Fork to background
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid > 0) {
        // Parent process, terminate it
        exit(EXIT_SUCCESS);
    }

    // Set new session ID for child process
    if (setsid() < 0) {
        perror("setsid");
        exit(EXIT_FAILURE);
    }

    // Close standard file descriptors
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
}

void printHelp(const char *cmd) {
    printf("Usage: %s [options]\n", cmd);
    printf("Options:\n");
    printf("  --listen-port PORT\t\tSpecifies the port the proxy will listen on.\n");
    printf("  --router-ip IP\t\tSpecifies the IP of the ZTE router to connect to.\n");
    printf("  --help\t\t\tDisplays this help message.\n");
}

int main(int argc, char **argv) {
    int listenSocket, clientSocket;
    struct sockaddr_in serverAddress, clientAddress;
    socklen_t clientAddressLength = sizeof(clientAddress);

    int listenPortFlag = 0, routerIpFlag = 0;

    struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"listen-port", required_argument, 0, 'l'},
        {"router-ip", required_argument, 0, 'r'},
        {0, 0, 0, 0}
    };

    int option_index = 0;
    int c;

    while ((c = getopt_long(argc, argv, "hl:r:", long_options, &option_index)) != -1) {
        switch (c) {
            case 'h':
                printHelp(argv[0]);
                exit(EXIT_SUCCESS);
                break;
            case 'l':
                listenPort = atoi(optarg);
                listenPortFlag = 1;
                break;
            case 'r':
                routerIp = optarg;
                routerIpFlag = 1;
                break;
            case '?':
                printHelp(argv[0]);
                exit(EXIT_FAILURE);
                break;
            default:
                abort();
        }
    }

    if (!listenPortFlag || !routerIpFlag) {
        fprintf(stderr, "Error: --listen-port and --router-ip are mandatory options.\n\n");
        printHelp(argv[0]);
        exit(EXIT_FAILURE);
    }

    // Initialize GnuTLS
    gnutls_global_init();

    // Create a socket to listen for incoming client connections
    if ((listenSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Failed to create socket");
        exit(EXIT_FAILURE);
    }

    // Allow the socket to be reused immediately after closure
    int enableReuse = 1;
    if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, &enableReuse, sizeof(enableReuse)) < 0) {
        perror("Failed to set socket options");
        exit(EXIT_FAILURE);
    }

    // Configure server address to bind to all interfaces
    memset(&serverAddress, 0, sizeof(serverAddress));
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(listenPort);
    serverAddress.sin_addr.s_addr = INADDR_ANY;  // Bind to all available interfaces

    // Bind the socket to the server address
    if (bind(listenSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {
        perror("Failed to bind socket");
        exit(EXIT_FAILURE);
    }

    // Start listening for incoming connections
    if (listen(listenSocket, 10) < 0) {
        perror("Failed to listen on socket");
        exit(EXIT_FAILURE);
    }

    printf("Proxy server is listening on port %d. ZTE Router IP is %s...\n", listenPort, routerIp);

    // Fork the process to run in the background
    forkToBackground();

    while (1) {
        // Accept an incoming client connection
        clientSocket = accept(listenSocket, (struct sockaddr *)&clientAddress, &clientAddressLength);
        if (clientSocket < 0) {
            perror("Failed to accept client");
            continue;
        }

        // Spawn a new thread to handle the client request
        pthread_t clientThread;
        if (pthread_create(&clientThread, NULL, handleClient, &clientSocket) != 0) {
            perror("Failed to create thread");
            close(clientSocket);
        }
        pthread_detach(clientThread);  // Detach the thread to release resources automatically
    }

    // Cleanup (Note: This part is unreachable in this example)
    gnutls_global_deinit();

    return 0;
}
